/*
Copyright 2025.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package config

import (
	"fmt"
	"strings"

	"github.com/MaximeWewer/wazuh-operator/api/v1alpha1"
	"github.com/MaximeWewer/wazuh-operator/internal/utils"
	"github.com/MaximeWewer/wazuh-operator/pkg/constants"
)

// ============================================================================
// Dashboard Config Builder (T013)
// ============================================================================

// DashboardAuthConfigBuilder builds opensearch_dashboards.yml authentication settings
type DashboardAuthConfigBuilder struct {
	authConfig      *v1alpha1.OpenSearchAuthConfigSpec
	resolvedSecrets map[string]string
	serverHost      string
	serverPort      int
	opensearchURL   string
}

// NewDashboardAuthConfigBuilder creates a new DashboardAuthConfigBuilder
func NewDashboardAuthConfigBuilder(spec *v1alpha1.OpenSearchAuthConfigSpec) *DashboardAuthConfigBuilder {
	return &DashboardAuthConfigBuilder{
		authConfig:      spec,
		resolvedSecrets: make(map[string]string),
		serverHost:      "0.0.0.0",
		serverPort:      int(constants.PortDashboardHTTP),
		opensearchURL:   fmt.Sprintf("https://localhost:%d", constants.PortIndexerREST),
	}
}

// WithSecret adds a resolved secret value
func (b *DashboardAuthConfigBuilder) WithSecret(key, value string) *DashboardAuthConfigBuilder {
	b.resolvedSecrets[key] = value
	return b
}

// WithServerHost sets the dashboard server host
func (b *DashboardAuthConfigBuilder) WithServerHost(host string) *DashboardAuthConfigBuilder {
	b.serverHost = host
	return b
}

// WithServerPort sets the dashboard server port
func (b *DashboardAuthConfigBuilder) WithServerPort(port int) *DashboardAuthConfigBuilder {
	b.serverPort = port
	return b
}

// WithOpenSearchURL sets the OpenSearch backend URL
func (b *DashboardAuthConfigBuilder) WithOpenSearchURL(url string) *DashboardAuthConfigBuilder {
	b.opensearchURL = url
	return b
}

// BuildAuthSection generates the authentication section of opensearch_dashboards.yml
func (b *DashboardAuthConfigBuilder) BuildAuthSection() string {
	var sb strings.Builder

	sb.WriteString("# Security Plugin Configuration\n")
	sb.WriteString("# Generated by Wazuh Operator\n\n")

	// Determine auth type
	authType := b.determineAuthType()

	sb.WriteString(fmt.Sprintf("opensearch_security.auth.type: \"%s\"\n", authType))

	// Build auth-specific configuration
	if b.authConfig.OIDC != nil && b.authConfig.OIDC.Enabled {
		sb.WriteString(b.buildOIDCDashboardConfig())
	}

	if b.authConfig.SAML != nil && b.authConfig.SAML.Enabled {
		sb.WriteString(b.buildSAMLDashboardConfig())
	}

	// Multi-auth configuration
	if b.isMultiAuthEnabled() {
		sb.WriteString(b.buildMultiAuthConfig())
	}

	return sb.String()
}

// determineAuthType returns the primary auth type for dashboard
func (b *DashboardAuthConfigBuilder) determineAuthType() string {
	// Count enabled auth types
	types := []string{}

	if b.authConfig.BasicAuth != nil && b.authConfig.BasicAuth.Enabled {
		types = append(types, "basicauth")
	}
	if b.authConfig.OIDC != nil && b.authConfig.OIDC.Enabled {
		types = append(types, "openid")
	}
	if b.authConfig.SAML != nil && b.authConfig.SAML.Enabled {
		types = append(types, "saml")
	}

	// Single type
	if len(types) == 1 {
		return types[0]
	}

	// Multiple types - use array format
	if len(types) > 1 {
		return fmt.Sprintf("[%s]", strings.Join(types, ", "))
	}

	// Default to basic auth
	return "basicauth"
}

// isMultiAuthEnabled returns true if multiple auth types are enabled
func (b *DashboardAuthConfigBuilder) isMultiAuthEnabled() bool {
	count := 0
	if b.authConfig.BasicAuth != nil && b.authConfig.BasicAuth.Enabled {
		count++
	}
	if b.authConfig.OIDC != nil && b.authConfig.OIDC.Enabled {
		count++
	}
	if b.authConfig.SAML != nil && b.authConfig.SAML.Enabled {
		count++
	}
	return count > 1
}

// ============================================================================
// OIDC Dashboard Config (T014)
// ============================================================================

// buildOIDCDashboardConfig generates OIDC-specific dashboard configuration
func (b *DashboardAuthConfigBuilder) buildOIDCDashboardConfig() string {
	var sb strings.Builder
	spec := b.authConfig.OIDC

	sb.WriteString("\n# OpenID Connect Configuration\n")

	// Connect URL
	sb.WriteString(fmt.Sprintf("opensearch_security.openid.connect_url: \"%s\"\n", spec.ConnectURL))

	// Client ID
	sb.WriteString(fmt.Sprintf("opensearch_security.openid.client_id: \"%s\"\n", spec.ClientID))

	// Client secret from resolved secrets
	if secret, ok := b.resolvedSecrets["oidc_client_secret"]; ok && secret != "" {
		sb.WriteString(fmt.Sprintf("opensearch_security.openid.client_secret: \"%s\"\n", secret))
	}

	// Scope
	if spec.Scope != "" {
		sb.WriteString(fmt.Sprintf("opensearch_security.openid.scope: \"%s\"\n", spec.Scope))
	}

	// Logout URL
	if spec.LogoutURL != "" {
		sb.WriteString(fmt.Sprintf("opensearch_security.openid.logout_url: \"%s\"\n", spec.LogoutURL))
	}

	// Dashboard-specific OIDC settings
	if spec.Dashboard != nil {
		if spec.Dashboard.RootURL != "" {
			sb.WriteString(fmt.Sprintf("opensearch_security.openid.root_url: \"%s\"\n", spec.Dashboard.RootURL))
		}

		if spec.Dashboard.LoginEndpoint != "" {
			sb.WriteString(fmt.Sprintf("opensearch_security.openid.login_endpoint: \"%s\"\n", spec.Dashboard.LoginEndpoint))
		}

		if spec.Dashboard.LogoutEndpoint != "" {
			sb.WriteString(fmt.Sprintf("opensearch_security.openid.logout_endpoint: \"%s\"\n", spec.Dashboard.LogoutEndpoint))
		}

		// Cookie settings
		if spec.Dashboard.CookiePrefix != "" {
			sb.WriteString(fmt.Sprintf("opensearch_security.cookie.prefix: \"%s\"\n", spec.Dashboard.CookiePrefix))
		}

		// Cookie password - auto-generate if not provided
		if secret, ok := b.resolvedSecrets["oidc_cookie_password"]; ok && secret != "" {
			sb.WriteString(fmt.Sprintf("opensearch_security.openid.cookie.password: \"%s\"\n", secret))
		} else {
			// Generate a random cookie password
			sb.WriteString(fmt.Sprintf("opensearch_security.openid.cookie.password: \"%s\"\n", utils.GenerateRandomPassword(32)))
		}

		// Additional cookies
		if len(spec.Dashboard.AdditionalCookies) > 0 {
			sb.WriteString("opensearch_security.openid.extra_storage.cookie_prefix: security_authentication_oidc\n")
			sb.WriteString(fmt.Sprintf("opensearch_security.openid.extra_storage.additional_cookies: %d\n", len(spec.Dashboard.AdditionalCookies)))
		}
	}

	return sb.String()
}

// ============================================================================
// SAML Dashboard Config (T015)
// ============================================================================

// buildSAMLDashboardConfig generates SAML-specific dashboard configuration
func (b *DashboardAuthConfigBuilder) buildSAMLDashboardConfig() string {
	var sb strings.Builder
	spec := b.authConfig.SAML

	sb.WriteString("\n# SAML Configuration\n")

	// Exchange key for signing SAML messages
	if secret, ok := b.resolvedSecrets["saml_exchange_key"]; ok && secret != "" {
		sb.WriteString(fmt.Sprintf("opensearch_security.saml.exchange_key: \"%s\"\n", secret))
	}

	// Dashboard-specific SAML settings
	if spec.Dashboard != nil {
		// Authn context
		if spec.Dashboard.RequestedAuthnContextRef != "" {
			sb.WriteString(fmt.Sprintf("opensearch_security.saml.requestedAuthnContextRef: \"%s\"\n", spec.Dashboard.RequestedAuthnContextRef))
		}

		// XSRF allowlist for SAML ACS endpoint
		if len(spec.Dashboard.XSRFAllowlist) > 0 {
			sb.WriteString("server.xsrf.allowlist:\n")
			for _, path := range spec.Dashboard.XSRFAllowlist {
				sb.WriteString(fmt.Sprintf("  - \"%s\"\n", path))
			}
		} else {
			// Default SAML ACS endpoint
			sb.WriteString("server.xsrf.allowlist:\n")
			sb.WriteString("  - \"/_opendistro/_security/saml/acs\"\n")
			sb.WriteString("  - \"/_opendistro/_security/saml/acs/idpinitiated\"\n")
			sb.WriteString("  - \"/_opendistro/_security/saml/logout\"\n")
		}
	} else {
		// Default XSRF allowlist for SAML
		sb.WriteString("server.xsrf.allowlist:\n")
		sb.WriteString("  - \"/_opendistro/_security/saml/acs\"\n")
		sb.WriteString("  - \"/_opendistro/_security/saml/acs/idpinitiated\"\n")
		sb.WriteString("  - \"/_opendistro/_security/saml/logout\"\n")
	}

	return sb.String()
}

// ============================================================================
// Multi-Auth Dashboard Config (T016)
// ============================================================================

// buildMultiAuthConfig generates multi-authentication configuration
func (b *DashboardAuthConfigBuilder) buildMultiAuthConfig() string {
	var sb strings.Builder

	sb.WriteString("\n# Multi-Auth Configuration\n")

	// Enable multiple authentication types
	sb.WriteString("opensearch_security.auth.multiple_auth_enabled: true\n")

	// Build ordered list of auth types
	type authMethod struct {
		name  string
		order int
	}

	var methods []authMethod

	if b.authConfig.BasicAuth != nil && b.authConfig.BasicAuth.Enabled {
		methods = append(methods, authMethod{"basicauth", b.authConfig.BasicAuth.Order})
	}
	if b.authConfig.OIDC != nil && b.authConfig.OIDC.Enabled {
		methods = append(methods, authMethod{"openid", b.authConfig.OIDC.Order})
	}
	if b.authConfig.SAML != nil && b.authConfig.SAML.Enabled {
		methods = append(methods, authMethod{"saml", b.authConfig.SAML.Order})
	}

	// Sort by order
	for i := 0; i < len(methods)-1; i++ {
		for j := i + 1; j < len(methods); j++ {
			if methods[j].order < methods[i].order {
				methods[i], methods[j] = methods[j], methods[i]
			}
		}
	}

	// Output auth types in order
	if len(methods) > 0 {
		types := make([]string, len(methods))
		for i, m := range methods {
			types[i] = fmt.Sprintf("\"%s\"", m.name)
		}
		sb.WriteString(fmt.Sprintf("opensearch_security.auth.type: [%s]\n", strings.Join(types, ", ")))
	}

	// Anonymous auth disable
	sb.WriteString("opensearch_security.auth.anonymous_auth_enabled: false\n")

	return sb.String()
}

// GetActiveAuthTypes returns a list of enabled dashboard auth types
func (b *DashboardAuthConfigBuilder) GetActiveAuthTypes() []string {
	var types []string

	if b.authConfig.BasicAuth != nil && b.authConfig.BasicAuth.Enabled {
		types = append(types, "basicauth")
	}
	if b.authConfig.OIDC != nil && b.authConfig.OIDC.Enabled {
		types = append(types, "openid")
	}
	if b.authConfig.SAML != nil && b.authConfig.SAML.Enabled {
		types = append(types, "saml")
	}

	return types
}

// NeedsDashboardRestart returns true if auth config changes require dashboard restart
func (b *DashboardAuthConfigBuilder) NeedsDashboardRestart(previous *v1alpha1.OpenSearchAuthConfigSpec) bool {
	if previous == nil {
		return true
	}

	// Check if auth types changed
	prevOIDC := previous.OIDC != nil && previous.OIDC.Enabled
	currOIDC := b.authConfig.OIDC != nil && b.authConfig.OIDC.Enabled
	if prevOIDC != currOIDC {
		return true
	}

	prevSAML := previous.SAML != nil && previous.SAML.Enabled
	currSAML := b.authConfig.SAML != nil && b.authConfig.SAML.Enabled
	if prevSAML != currSAML {
		return true
	}

	// Check if OIDC connect URL changed
	if currOIDC && previous.OIDC != nil {
		if b.authConfig.OIDC.ConnectURL != previous.OIDC.ConnectURL {
			return true
		}
		if b.authConfig.OIDC.ClientID != previous.OIDC.ClientID {
			return true
		}
	}

	// Check if SAML config changed
	if currSAML && previous.SAML != nil {
		if b.authConfig.SAML.IdpMetadataURL != previous.SAML.IdpMetadataURL {
			return true
		}
		if b.authConfig.SAML.IdpEntityID != previous.SAML.IdpEntityID {
			return true
		}
	}

	return false
}
