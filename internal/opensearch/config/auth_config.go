/*
Copyright 2025.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package config

import (
	"fmt"
	"sort"
	"strings"

	"github.com/MaximeWewer/wazuh-operator/api/v1alpha1"
)

// AuthConfigBuilder builds the config.yml authentication section from CRD spec
type AuthConfigBuilder struct {
	authConfig *v1alpha1.OpenSearchAuthConfigSpec
	// Resolved secrets (populated by reconciler)
	resolvedSecrets map[string]string
}

// NewAuthConfigBuilder creates a new AuthConfigBuilder
func NewAuthConfigBuilder(spec *v1alpha1.OpenSearchAuthConfigSpec) *AuthConfigBuilder {
	return &AuthConfigBuilder{
		authConfig:      spec,
		resolvedSecrets: make(map[string]string),
	}
}

// WithSecret adds a resolved secret value
func (b *AuthConfigBuilder) WithSecret(key, value string) *AuthConfigBuilder {
	b.resolvedSecrets[key] = value
	return b
}

// AuthDomainConfig represents a single authentication domain configuration
type AuthDomainConfig struct {
	Name                string
	Order               int
	HTTPEnabled         bool
	TransportEnabled    bool
	Challenge           bool
	AuthenticatorType   string
	AuthenticatorConfig map[string]interface{}
	BackendType         string
	BackendConfig       map[string]interface{}
	Description         string
}

// BuildSecurityConfig generates the complete config.yml content
func (b *AuthConfigBuilder) BuildSecurityConfig() string {
	var sb strings.Builder

	sb.WriteString("# OpenSearch Security Plugin Configuration\n")
	sb.WriteString("# Generated by Wazuh Operator\n")
	sb.WriteString("---\n")
	sb.WriteString("_meta:\n")
	sb.WriteString("  type: \"config\"\n")
	sb.WriteString("  config_version: 2\n\n")

	sb.WriteString("config:\n")
	sb.WriteString("  dynamic:\n")
	sb.WriteString("    http:\n")
	sb.WriteString("      anonymous_auth_enabled: false\n")

	// Build authentication domains
	domains := b.buildAuthDomains()
	if len(domains) > 0 {
		sb.WriteString("    authc:\n")
		for _, domain := range domains {
			sb.WriteString(b.formatAuthDomain(domain))
		}
	}

	// Build authorization domains (for LDAP)
	authzDomains := b.buildAuthzDomains()
	if len(authzDomains) > 0 {
		sb.WriteString("    authz:\n")
		for _, domain := range authzDomains {
			sb.WriteString(b.formatAuthzDomain(domain))
		}
	}

	// Additional settings
	sb.WriteString("    do_not_fail_on_forbidden: false\n")
	sb.WriteString("    do_not_fail_on_forbidden_empty: false\n")
	sb.WriteString("    multi_rolespan_enabled: true\n")
	sb.WriteString("    respect_request_indices_options: true\n")

	return sb.String()
}

// buildAuthDomains collects and sorts all enabled auth domains
func (b *AuthConfigBuilder) buildAuthDomains() []AuthDomainConfig {
	var domains []AuthDomainConfig

	// Basic Auth
	if b.authConfig.BasicAuth != nil && b.authConfig.BasicAuth.Enabled {
		domains = append(domains, b.buildBasicAuthDomain(b.authConfig.BasicAuth))
	}

	// OIDC
	if b.authConfig.OIDC != nil && b.authConfig.OIDC.Enabled {
		domains = append(domains, b.buildOIDCAuthDomain(b.authConfig.OIDC))
	}

	// SAML
	if b.authConfig.SAML != nil && b.authConfig.SAML.Enabled {
		domains = append(domains, b.buildSAMLAuthDomain(b.authConfig.SAML))
	}

	// LDAP
	if b.authConfig.LDAP != nil && b.authConfig.LDAP.Enabled {
		domains = append(domains, b.buildLDAPAuthDomain(b.authConfig.LDAP))
	}

	// Sort by order
	sort.Slice(domains, func(i, j int) bool {
		return domains[i].Order < domains[j].Order
	})

	return domains
}

// buildAuthzDomains collects authorization domains (LDAP only for now)
func (b *AuthConfigBuilder) buildAuthzDomains() []AuthDomainConfig {
	var domains []AuthDomainConfig

	if b.authConfig.LDAP != nil && b.authConfig.LDAP.Enabled &&
		b.authConfig.LDAP.Authorization != nil && b.authConfig.LDAP.Authorization.Enabled {
		domains = append(domains, b.buildLDAPAuthzDomain(b.authConfig.LDAP))
	}

	return domains
}

// formatAuthDomain formats a single auth domain for config.yml
func (b *AuthConfigBuilder) formatAuthDomain(domain AuthDomainConfig) string {
	var sb strings.Builder

	sb.WriteString(fmt.Sprintf("      %s:\n", domain.Name))
	if domain.Description != "" {
		sb.WriteString(fmt.Sprintf("        description: \"%s\"\n", domain.Description))
	}
	sb.WriteString(fmt.Sprintf("        http_enabled: %t\n", domain.HTTPEnabled))
	sb.WriteString(fmt.Sprintf("        transport_enabled: %t\n", domain.TransportEnabled))
	sb.WriteString(fmt.Sprintf("        order: %d\n", domain.Order))

	// HTTP authenticator
	sb.WriteString("        http_authenticator:\n")
	sb.WriteString(fmt.Sprintf("          type: \"%s\"\n", domain.AuthenticatorType))
	sb.WriteString(fmt.Sprintf("          challenge: %t\n", domain.Challenge))

	// Authenticator config if present
	if len(domain.AuthenticatorConfig) > 0 {
		sb.WriteString("          config:\n")
		sb.WriteString(formatConfigMap(domain.AuthenticatorConfig, 12))
	}

	// Authentication backend
	sb.WriteString("        authentication_backend:\n")
	sb.WriteString(fmt.Sprintf("          type: \"%s\"\n", domain.BackendType))

	// Backend config if present
	if len(domain.BackendConfig) > 0 {
		sb.WriteString("          config:\n")
		sb.WriteString(formatConfigMap(domain.BackendConfig, 12))
	}

	return sb.String()
}

// formatAuthzDomain formats a single authorization domain for config.yml
func (b *AuthConfigBuilder) formatAuthzDomain(domain AuthDomainConfig) string {
	var sb strings.Builder

	sb.WriteString(fmt.Sprintf("      %s:\n", domain.Name))
	if domain.Description != "" {
		sb.WriteString(fmt.Sprintf("        description: \"%s\"\n", domain.Description))
	}
	sb.WriteString(fmt.Sprintf("        http_enabled: %t\n", domain.HTTPEnabled))

	// Authorization backend
	sb.WriteString("        authorization_backend:\n")
	sb.WriteString(fmt.Sprintf("          type: \"%s\"\n", domain.BackendType))

	if len(domain.BackendConfig) > 0 {
		sb.WriteString("          config:\n")
		sb.WriteString(formatConfigMap(domain.BackendConfig, 12))
	}

	return sb.String()
}

// ============================================================================
// Basic Auth Domain Builder (T009)
// ============================================================================

// buildBasicAuthDomain creates the basic auth domain configuration
func (b *AuthConfigBuilder) buildBasicAuthDomain(spec *v1alpha1.BasicAuthSpec) AuthDomainConfig {
	return AuthDomainConfig{
		Name:              "basic_internal_auth_domain",
		Order:             spec.Order,
		HTTPEnabled:       spec.HTTPEnabled,
		TransportEnabled:  spec.TransportEnabled,
		Challenge:         spec.Challenge,
		AuthenticatorType: "basic",
		BackendType:       "internal",
		Description:       "Authenticate via HTTP Basic against internal users database",
	}
}

// DefaultBasicAuthDomain returns the default basic auth domain configuration
func DefaultBasicAuthDomain() AuthDomainConfig {
	return AuthDomainConfig{
		Name:              "basic_internal_auth_domain",
		Order:             0,
		HTTPEnabled:       true,
		TransportEnabled:  true,
		Challenge:         true,
		AuthenticatorType: "basic",
		BackendType:       "internal",
		Description:       "Authenticate via HTTP Basic against internal users database",
	}
}

// ============================================================================
// Helper Functions
// ============================================================================

// formatConfigMap formats a map for YAML output with proper indentation
func formatConfigMap(config map[string]interface{}, indent int) string {
	var sb strings.Builder
	prefix := strings.Repeat(" ", indent)

	// Sort keys for consistent output
	keys := make([]string, 0, len(config))
	for k := range config {
		keys = append(keys, k)
	}
	sort.Strings(keys)

	for _, key := range keys {
		value := config[key]
		switch v := value.(type) {
		case string:
			if strings.Contains(v, "\n") || strings.Contains(v, ":") || strings.Contains(v, "#") {
				sb.WriteString(fmt.Sprintf("%s%s: \"%s\"\n", prefix, key, v))
			} else {
				sb.WriteString(fmt.Sprintf("%s%s: %s\n", prefix, key, v))
			}
		case bool:
			sb.WriteString(fmt.Sprintf("%s%s: %t\n", prefix, key, v))
		case int:
			sb.WriteString(fmt.Sprintf("%s%s: %d\n", prefix, key, v))
		case []string:
			sb.WriteString(fmt.Sprintf("%s%s:\n", prefix, key))
			for _, item := range v {
				sb.WriteString(fmt.Sprintf("%s  - \"%s\"\n", prefix, item))
			}
		case map[string]interface{}:
			sb.WriteString(fmt.Sprintf("%s%s:\n", prefix, key))
			sb.WriteString(formatConfigMap(v, indent+2))
		default:
			sb.WriteString(fmt.Sprintf("%s%s: %v\n", prefix, key, v))
		}
	}

	return sb.String()
}

// GetActiveAuthMethods returns a list of enabled authentication method names
func (b *AuthConfigBuilder) GetActiveAuthMethods() []string {
	var methods []string

	if b.authConfig.BasicAuth != nil && b.authConfig.BasicAuth.Enabled {
		methods = append(methods, "basic")
	}
	if b.authConfig.OIDC != nil && b.authConfig.OIDC.Enabled {
		methods = append(methods, "oidc")
	}
	if b.authConfig.SAML != nil && b.authConfig.SAML.Enabled {
		methods = append(methods, "saml")
	}
	if b.authConfig.LDAP != nil && b.authConfig.LDAP.Enabled {
		methods = append(methods, "ldap")
	}

	return methods
}

// ValidateChallengeSettings checks that only one auth domain has challenge=true
func (b *AuthConfigBuilder) ValidateChallengeSettings() error {
	challengeCount := 0

	if b.authConfig.BasicAuth != nil && b.authConfig.BasicAuth.Enabled && b.authConfig.BasicAuth.Challenge {
		challengeCount++
	}
	if b.authConfig.OIDC != nil && b.authConfig.OIDC.Enabled && b.authConfig.OIDC.Challenge {
		challengeCount++
	}
	if b.authConfig.SAML != nil && b.authConfig.SAML.Enabled && b.authConfig.SAML.Challenge {
		challengeCount++
	}
	if b.authConfig.LDAP != nil && b.authConfig.LDAP.Enabled && b.authConfig.LDAP.Challenge {
		challengeCount++
	}

	if challengeCount > 1 {
		return fmt.Errorf("only one authentication domain can have challenge=true, found %d", challengeCount)
	}

	return nil
}
