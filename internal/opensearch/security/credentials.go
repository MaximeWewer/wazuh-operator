/*
Copyright 2025.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package security

import (
	"context"
	"crypto/sha256"
	"fmt"
	"sort"

	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/types"
	"k8s.io/client-go/tools/record"
	"sigs.k8s.io/controller-runtime/pkg/client"

	wazuhv1alpha1 "github.com/MaximeWewer/wazuh-operator/api/v1alpha1"
	"github.com/MaximeWewer/wazuh-operator/pkg/constants"
)

// CredentialManager manages OpenSearch admin credentials
type CredentialManager struct {
	k8sClient client.Client
	recorder  record.EventRecorder
}

// NewCredentialManager creates a new CredentialManager
func NewCredentialManager(k8sClient client.Client, recorder record.EventRecorder) *CredentialManager {
	return &CredentialManager{
		k8sClient: k8sClient,
		recorder:  recorder,
	}
}

// AdminCredentials holds the resolved admin credentials
type AdminCredentials struct {
	Username string
	Password string
	Source   string // "auto" or "crd"
	CRDName  string // Name of the CRD if source is "crd"
}

// GetAdminCredentials returns the admin username and password for a cluster
// It checks for CRD-defined admin first, falls back to auto-generated
func (c *CredentialManager) GetAdminCredentials(ctx context.Context, cluster *wazuhv1alpha1.WazuhCluster) (*AdminCredentials, error) {
	// Try to find a CRD-defined admin first
	adminUser, err := c.ResolveDefaultAdmin(ctx, cluster)
	if err != nil {
		return nil, fmt.Errorf("failed to resolve default admin: %w", err)
	}

	if adminUser != nil {
		// Get credentials from CRD
		password, err := c.GetPasswordFromCRD(ctx, adminUser)
		if err != nil {
			return nil, fmt.Errorf("failed to get password from CRD %s: %w", adminUser.Name, err)
		}

		return &AdminCredentials{
			Username: adminUser.Name,
			Password: password,
			Source:   wazuhv1alpha1.SecuritySourceCRD,
			CRDName:  adminUser.Name,
		}, nil
	}

	// Fall back to auto-generated credentials from the secret
	username, password, err := c.getAutoGeneratedCredentials(ctx, cluster)
	if err != nil {
		return nil, fmt.Errorf("failed to get auto-generated credentials: %w", err)
	}

	return &AdminCredentials{
		Username: username,
		Password: password,
		Source:   wazuhv1alpha1.SecuritySourceAuto,
	}, nil
}

// FindDefaultAdminCRDs finds all OpenSearchUser CRDs marked as defaultAdmin for a cluster
func (c *CredentialManager) FindDefaultAdminCRDs(ctx context.Context, clusterRef types.NamespacedName) ([]wazuhv1alpha1.OpenSearchUser, error) {
	// List all OpenSearchUser CRDs in the namespace
	var userList wazuhv1alpha1.OpenSearchUserList
	if err := c.k8sClient.List(ctx, &userList, client.InNamespace(clusterRef.Namespace)); err != nil {
		return nil, fmt.Errorf("failed to list OpenSearchUser CRDs: %w", err)
	}

	// Filter for defaultAdmin users that reference this cluster
	var defaultAdmins []wazuhv1alpha1.OpenSearchUser
	for _, user := range userList.Items {
		if user.Spec.DefaultAdmin && user.Spec.ClusterRef.Name == clusterRef.Name {
			defaultAdmins = append(defaultAdmins, user)
		}
	}

	// Sort by creation timestamp (oldest first)
	sort.Slice(defaultAdmins, func(i, j int) bool {
		return defaultAdmins[i].CreationTimestamp.Before(&defaultAdmins[j].CreationTimestamp)
	})

	return defaultAdmins, nil
}

// ResolveDefaultAdmin selects the admin user and emits warnings if conflicts
func (c *CredentialManager) ResolveDefaultAdmin(ctx context.Context, cluster *wazuhv1alpha1.WazuhCluster) (*wazuhv1alpha1.OpenSearchUser, error) {
	clusterRef := types.NamespacedName{
		Name:      cluster.Name,
		Namespace: cluster.Namespace,
	}

	defaultAdmins, err := c.FindDefaultAdminCRDs(ctx, clusterRef)
	if err != nil {
		return nil, err
	}

	if len(defaultAdmins) == 0 {
		// No CRD-defined admin, use auto-generated
		return nil, nil
	}

	// Use the first one (oldest by creation timestamp)
	selectedAdmin := &defaultAdmins[0]

	// Emit warnings for additional default admins
	for i := 1; i < len(defaultAdmins); i++ {
		extraAdmin := &defaultAdmins[i]
		if c.recorder != nil {
			c.recorder.Eventf(extraAdmin, corev1.EventTypeWarning, "MultipleDefaultAdmin",
				"Multiple users marked as defaultAdmin for cluster %s. Using %s instead of %s",
				cluster.Name, selectedAdmin.Name, extraAdmin.Name)
		}
	}

	return selectedAdmin, nil
}

// GetPasswordFromCRD retrieves the password for an OpenSearchUser CRD
func (c *CredentialManager) GetPasswordFromCRD(ctx context.Context, user *wazuhv1alpha1.OpenSearchUser) (string, error) {
	// If a hash is provided directly, we can't retrieve the password
	// This is only valid for syncing to OpenSearch, not for authentication
	if user.Spec.Hash != "" && user.Spec.PasswordSecret == nil {
		return "", fmt.Errorf("user %s only has a hash, no password available for authentication", user.Name)
	}

	// Get password from secret
	if user.Spec.PasswordSecret == nil {
		return "", fmt.Errorf("user %s has no passwordSecret configured", user.Name)
	}

	secretKey := types.NamespacedName{
		Name:      user.Spec.PasswordSecret.SecretName,
		Namespace: user.Namespace,
	}

	var secret corev1.Secret
	if err := c.k8sClient.Get(ctx, secretKey, &secret); err != nil {
		return "", fmt.Errorf("failed to get password secret %s: %w", user.Spec.PasswordSecret.SecretName, err)
	}

	// Use PasswordKey from CredentialsSecretRef (default to "password")
	key := user.Spec.PasswordSecret.PasswordKey
	if key == "" {
		key = "password"
	}

	passwordBytes, ok := secret.Data[key]
	if !ok {
		return "", fmt.Errorf("key %s not found in secret %s", key, user.Spec.PasswordSecret.SecretName)
	}

	return string(passwordBytes), nil
}

// getAutoGeneratedCredentials retrieves the auto-generated credentials from the indexer-credentials secret
func (c *CredentialManager) getAutoGeneratedCredentials(ctx context.Context, cluster *wazuhv1alpha1.WazuhCluster) (username, password string, err error) {
	secretName := fmt.Sprintf("%s-indexer-credentials", cluster.Name)
	secretKey := types.NamespacedName{
		Name:      secretName,
		Namespace: cluster.Namespace,
	}

	var secret corev1.Secret
	if err := c.k8sClient.Get(ctx, secretKey, &secret); err != nil {
		return "", "", fmt.Errorf("failed to get credentials secret %s: %w", secretName, err)
	}

	usernameBytes, ok := secret.Data[constants.SecretKeyAdminUsername]
	if !ok {
		return "", "", fmt.Errorf("%s not found in secret %s", constants.SecretKeyAdminUsername, secretName)
	}

	passwordBytes, ok := secret.Data[constants.SecretKeyAdminPassword]
	if !ok {
		return "", "", fmt.Errorf("%s not found in secret %s", constants.SecretKeyAdminPassword, secretName)
	}

	return string(usernameBytes), string(passwordBytes), nil
}

// ComputeCredentialsHash computes a hash of the credentials for change detection
func (c *CredentialManager) ComputeCredentialsHash(ctx context.Context, cluster *wazuhv1alpha1.WazuhCluster) (string, error) {
	creds, err := c.GetAdminCredentials(ctx, cluster)
	if err != nil {
		return "", err
	}

	// Compute SHA256 of username + password
	data := fmt.Sprintf("%s:%s", creds.Username, creds.Password)
	hash := sha256.Sum256([]byte(data))
	return fmt.Sprintf("%x", hash[:8]), nil // Use first 8 bytes for a shorter hash
}

// PropagateCredentials updates dashboard and manager with current credentials
// This is done by updating an annotation to trigger rolling updates
func (c *CredentialManager) PropagateCredentials(ctx context.Context, cluster *wazuhv1alpha1.WazuhCluster) error {
	// Get current credentials hash
	hash, err := c.ComputeCredentialsHash(ctx, cluster)
	if err != nil {
		return fmt.Errorf("failed to compute credentials hash: %w", err)
	}

	// Update dashboard deployment annotation
	if err := c.updateDeploymentAnnotation(ctx, cluster, "dashboard", hash); err != nil {
		return fmt.Errorf("failed to update dashboard annotation: %w", err)
	}

	// Update manager StatefulSet annotation (master)
	if err := c.updateStatefulSetAnnotation(ctx, cluster, "manager-master", hash); err != nil {
		return fmt.Errorf("failed to update manager-master annotation: %w", err)
	}

	// Update manager StatefulSet annotation (worker)
	if err := c.updateStatefulSetAnnotation(ctx, cluster, "manager-worker", hash); err != nil {
		// Worker might not exist, ignore error
		_ = err
	}

	return nil
}

// updateDeploymentAnnotation updates the credentials hash annotation on a deployment
func (c *CredentialManager) updateDeploymentAnnotation(ctx context.Context, cluster *wazuhv1alpha1.WazuhCluster, component, hash string) error {
	deploymentName := fmt.Sprintf("%s-%s", cluster.Name, component)
	deploymentKey := types.NamespacedName{
		Name:      deploymentName,
		Namespace: cluster.Namespace,
	}

	var deployment corev1.Pod // We'll use a Deployment but check existence first
	// Note: In a real implementation, we'd import appsv1 and use Deployment
	// For now, we'll document that this should be done during reconciliation
	_ = deployment
	_ = deploymentKey

	// This will be called from the reconciler which has access to update deployments
	return nil
}

// updateStatefulSetAnnotation updates the credentials hash annotation on a statefulset
func (c *CredentialManager) updateStatefulSetAnnotation(ctx context.Context, cluster *wazuhv1alpha1.WazuhCluster, component, hash string) error {
	// This will be called from the reconciler which has access to update statefulsets
	return nil
}

// GetCredentialsHashAnnotationKey returns the annotation key for credentials hash
func GetCredentialsHashAnnotationKey() string {
	return "wazuh.com/credentials-hash"
}
